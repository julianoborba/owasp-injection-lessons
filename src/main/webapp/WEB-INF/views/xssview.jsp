<html>
	<head>
		<title>Injection</title>
		
		<!-- let's do some hacking here -->
		<style>${input_param}</style>
		
	</head>
	<body>
		<div class="container">
			<h1><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">https://www.owasp.org</a> - XSS or Cross Site Scripting</h1>
			<p>Let's treat an HTML page like a template, with slots where a developer is allowed to put untrusted data. These slots cover the vast majority of the common places where a developer might want to put untrusted data. Putting untrusted data in other places in the HTML is not allowed. This is a "whitelist" model, that denies everything that is not specifically allowed.</p>
			<p>So, we have rules. You do not have to allow all the rules in your organization. Many organizations may find that allowing only Rule 2 and Rule3 are sufficient for their needs.</p>
			
			<!-- let's do some hacking here -->
			<!--${input_param}-->
			
			<h2>The rules</h2>
		    <ol>
			    <li>
			    	Never Insert Untrusted Data Except in Allowed Locations
			    	<p>The first rule is to deny all - don't put untrusted data into your HTML document unless it is within one of the slots defined in Rule 2 through Rule 6.</p>
			    </li>
			    <li>
			    	HTML Escape Before Inserting Untrusted Data into HTML Element Content
			    	<p>Is for when you want to put untrusted data directly into the HTML body somewhere. Like here:
			    	
			    	<!-- let's do some hacking here -->
			    	${input_param}
			    	
			    	</p>
			    </li>
			    <li>
			    	Attribute Escape Before Inserting Untrusted Data into HTML Common Attributes
			    	<p>Is for putting untrusted data into typical attribute values like width, name, value, etc. Like here:
			    	
			    	<!-- let's do some hacking here -->
			    	<img src="${input_param}" height="72" width="72">
			    	<!-- image src for fun tests purposes input_param=https://i.imgur.com/OgRnuka.gif -->
			    	
			    	</p>
			    	
			    </li>
			    <li>
			    	JavaScript Escape Before Inserting Untrusted Data into JavaScript Data Values
			    	<p>Concerns dynamically generated JavaScript code - both script blocks and event-handler attributes. The only safe place to put untrusted data into this code is inside a quoted "data value". Like here:
			    	
			    	<!-- let's do some hacking here -->
			    	<img onmouseover="alert('${input_param}')" src="http://www.freeiconspng.com/uploads/hand-cursor-png-click-cursor-hand-icon-13.png" height="22" width="22">
			    	
			    	. Please note there are some JavaScript functions that can never safely use untrusted data as input - EVEN IF JAVASCRIPT ESCAPED! Like in eval() function and his friends.</p>
			    </li>
			    <ol>
				    <li>
				    	HTML escape JSON values in an HTML context and read the data with JSON.parse
				    	<p>The need for having data dynamically generated by an application in a javascript context is common, usually by AJAX requests. Ensure returned Content-Type header is application/json and not text/html. Also HTML escape JSON values in an HTML context and read the data with JSON.parse, like this:
				    	
						<script id="init_data" type="application/json">
							${input_param}
						</script>
						<!-- json for tests purposes input_param={ "name":"John", "age":30, "city":"New York"} -->
						<script>
							var dataElement = document.getElementById('init_data');
							var jsonText = escape(dataElement.textContent || dataElement.innerText);
							var initData = JSON.parse(unescape(jsonText));
							document.write(initData.name + ", " + initData.age + ".");	
						</script>
						
						</p>
						<p>An alternative to escaping and unescaping JSON directly in JavaScript, is to normalize JSON server-side by converting '<' to '\u003c' before delivering it to the browser:
						
						<!-- let's do some hacking here -->
						<script id="init_data" type="application/json">
							${input_param}
						</script>
						<!-- json for fun tests purposes input_param={ "name":"John<img src="https://i.imgur.com/OgRnuka.gif" height="72" width="72">", "age":30, "city":"New York"} -->
						<script>
							var dataElement = document.getElementById('init_data');
							document.write(dataElement.textContent || dataElement.innerText);
						</script>
						
						</p>
				    </li>
			    </ol>
			    <li>
			    	CSS Escape And Strictly Validate Before Inserting Untrusted Data into HTML Style Property Values
			    	<p>Is for when you want to put untrusted data into a stylesheet or a style tag. Please note there are some CSS contexts that can never safely use untrusted data as input - EVEN IF PROPERLY CSS ESCAPED! You will have to ensure that URLs only start with "http" not "javascript" and that properties never start with "expression".</p>
			    </li>
			   	<li>
			    	URL Escape Before Inserting Untrusted Data into HTML URL Parameter Values
			    	<p>Is for when you want to put untrusted data into HTTP GET parameter value. Like here:
			    	
			    	<!-- let's do some hacking here -->
			    	<a href="http://www.google.com?q=${input_param}">link</a >
			    	
			    	</p>
			    	<p>Do not encode complete or relative URL's with URL encoding! If untrusted input is meant to be placed into href, src or other URL-based attributes, it should be validated to make sure it does not point to an unexpected protocol, especially Javascript links. URL's should then be encoded based on the context of display like any other piece of data. For example, user driven URL's in HREF links should be attribute encoded.
			    	
			    	<!-- let's do some hacking here -->
			    	<a href="${input_param}">link</a>
			    	
			    	</p>
			    </li>
			    <li>
			    	Sanitize HTML Markup with a Library Designed for the Job
			    	<p>If your application handles markup -- untrusted input that is supposed to contain HTML -- it can be very difficult to validate. Encoding is also difficult, since it would break all the tags that are supposed to be in the input. Therefore, you need a library that can parse and clean HTML formatted text. There are several available at OWASP that are simple to use.
			    	
			    	<!-- let's do some hacking here -->
			    	${input_param}
			    	<!-- broken html tag for tests purposes input_param=<p>Hello, <b>World!</b> -->
			    	
			    	</p>
			    </li>
			   	<li>
			    	Prevent DOM-based XSS
			    	<p>For details on what DOM-based XSS is, and defenses against this type of XSS flaw, please see the OWASP article on <a href="https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet">DOM based XSS Prevention Cheat Sheet</a>.</p>
			    </li>
		    </ol>
		    <h2>Bonus rules</h2>
		    <ol>
			    <li>
			    	Use HTTPOnly cookie flag
			    	<p>Using the HttpOnly flag when generating a cookie helps mitigate the risk of client side script accessing the protected cookie (if the browser supports it). In this case, we setup the flag in our Jetty web.xml file.</p>
			    </li>
			    <li>
			    	Implement Content Security Policy
			    	<p>There is another good complex solution to mitigate the impact of an XSS flaw called Content Security Policy. It's a browser side mechanism which allows you to create source whitelists for client side resources of your web application, e.g. JavaScript, CSS, images, etc. CSP via special HTTP header instructs the browser to only execute or render resources from those sources. In Java, you can read a <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html">section that discusses Spring Security's support for adding various security headers to the response</a>.</p>
			   </li>
			    <li>
			    	Use an Auto-Escaping Template System
			    	<p>Many web application frameworks provide automatic contextual escaping functionality such as AngularJS strict contextual escaping and Go Templates. Use these technologies when you can.</p>
			    </li>
			    <li>
			    	Use the X-XSS-Protection Response Header
			    	<p>This HTTP response header enables the Cross-site scripting (XSS) filter built into some modern web browsers. This header is usually enabled by default anyway, so the role of this header is to re-enable the filter for this particular website if it was disabled by the user. In Java, you can read a <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html">section that discusses Spring Security's support for adding various security headers to the response</a>.</p>
			    </li>
			    
			    <!-- let's do some hacking here -->
			    <${input_param} src="http://media.urbantabloid.com/wp-content/uploads/2014/12/A-bunny-stealing-your-cookie.jpg"></${input_param}>
			    
		    </ol>
		    
		    <!-- let's do some hacking here -->
			<div ${input_param}="imsafe"></div>  
			
			<hr>
			<p>Try to catch me - <a href="http://tools.kali.org/tools-listing">http://tools.kali.org/tools-listing</a></p>
		</div>
		
		<!-- let's do some hacking here -->
		<script>${input_param}</script>
		
	</body>
</html>
